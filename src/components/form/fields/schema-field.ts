import { LimeElementsAdapter } from '../adapters';
import JSONSchemaField from 'react-jsonschema-form/lib/components/fields/SchemaField';
import React from 'react';
import { FieldProps } from './types';
import { isEmpty, capitalize, union, isEqual, isPlainObject } from 'lodash-es';
import { retrieveSchema } from 'react-jsonschema-form/lib/utils';

const hasCustomComponent = (schema): boolean => {
    return Boolean(schema.lime?.component?.name);
};

const verifyCustomComponentIsDefined = (elementName): void => {
    const supportsCustomElements = 'customElements' in window;

    if (!supportsCustomElements) {
        throw new Error(
            'Custom form elements are not supported by this browser!'
        );
    }

    if (!customElements.get(elementName)) {
        throw new Error(`Custom form element '${elementName}' is not defined!`);
    }
};

const getCustomComponent = (
    schema
): { name: string; props: { [key: string]: any } } => {
    const name = schema.lime?.component?.name;
    const props = schema.lime?.component?.props || {};

    return { name: name, props: props };
};

export class SchemaField extends React.Component<FieldProps> {
    state = {
        modified: false,
    };

    constructor(props) {
        super(props);
        this.handleChange = this.handleChange.bind(this);
        this.handleCustomComponentChange = this.handleCustomComponentChange.bind(
            this
        );
        this.initState();
    }

    private initState() {
        if (this.hasValue()) {
            this.state.modified = true;
        }
    }

    private hasValue() {
        const value = this.getValue();
        if (!value) {
            return false;
        }

        if (Array.isArray(value)) {
            return !!value.length;
        }

        if (typeof value === 'object') {
            return !isEmpty(value);
        }

        return true;
    }

    private getLabel() {
        const { schema } = this.props;

        return schema.title;
    }

    private isInvalid() {
        const { modified } = this.state;
        const { errorSchema } = this.props;

        if (!modified) {
            return false;
        }

        return !isEmpty(errorSchema);
    }

    private isRequired() {
        const { required, schema } = this.props;

        return required || schema.minItems > 0;
    }

    private getHelperText() {
        const { errorSchema, schema } = this.props;

        if (!this.isInvalid()) {
            return schema.description;
        }

        if (!isEmpty(errorSchema)) {
            return capitalize(errorSchema.__errors[0]);
        }

        return schema.description;
    }

    private getValue() {
        const { formData } = this.props;

        return formData;
    }

    private handleCustomComponentChange(event) {
        event.stopPropagation();

        this.handleChange(event.detail);
    }

    private handleChange(data) {
        this.setState({ modified: true });

        const newData = this.resetDependentFields(data);

        this.props.onChange(newData);
    }

    private getSchemaForData(data) {
        const { schema } = this.props;
        const { definitions } = this.props.registry;

        if (!schema.hasOwnProperty('$ref')) {
            return schema;
        }

        return retrieveSchema(schema, definitions, data);
    }

    /**
     * Given the data for the current SchemaField, detect if the changed data
     * has any other fields that are dependent on it, and if so reset those dependent fields
     * (by deleting them from the data so that their defaults are populated on the next rerender).
     * Call onChange with the updated data
     *
     * @param {any} newData The form data from a change event
     *
     * @returns {void}
     */
    private resetDependentFields(newData) {
        const { formData: oldData } = this.props;

        // Dependencies only exist on object types
        if (!isPlainObject(newData)) {
            return newData;
        }

        // Get the schema generated by the current data
        const currentSchema = this.getSchemaForData(oldData);

        // Get the new schema that is calculated for the new data
        const newSchema = this.getSchemaForData(newData);

        // Get property keys whose schema changed due to the new data.
        // These properties that have changed are the properties that are dependent on
        // data that has changed in the current onChange event
        const dependentPropertyKeys = this.getDifferentKeys(
            newSchema.properties,
            currentSchema.properties
        );

        // Reset keys that are dependent on the changed value.
        // The values for these dependent fields will be repopulated
        // with defaults during the next render
        for (const dependentPropertyKey of dependentPropertyKeys) {
            delete newData[dependentPropertyKey];
        }

        return newData;
    }

    /**
     * Given two objects, get a list of keys for each value that is different between
     * the two objects. Compares using deep comparison
     *
     * @param {object} a first object
     * @param {object} b second object
     *
     * @returns {any[]} the array of keys
     */
    private getDifferentKeys(a: object, b: object): any[] {
        const keys = union(Object.keys(a), Object.keys(b));
        return keys.filter((key) => {
            return !isEqual(b[key], a[key]);
        });
    }

    private buildCustomComponentProps() {
        const {
            disabled,
            readonly,
            name,
            registry,
            schema,
            errorSchema,
        } = this.props;

        return {
            value: this.getValue(),
            required: this.isRequired(),
            readonly: readonly,
            disabled: disabled,
            invalid: this.isInvalid(),
            label: this.getLabel(),
            helperText: this.getHelperText(),
            formInfo: {
                schema: schema,
                rootSchema: registry.formContext.schema,
                errorSchema: errorSchema,
                rootValue: registry.formContext.rootValue,
                name: name,
            },
        };
    }

    private renderCustomComponent(props: FieldProps) {
        const { name, props: userDefinedComponentProps } = getCustomComponent(
            props.schema
        );

        verifyCustomComponentIsDefined(name);

        return React.createElement(LimeElementsAdapter, {
            name: name,
            elementProps: {
                ...userDefinedComponentProps,
                ...this.buildCustomComponentProps(),
            },
            events: {
                change: this.handleCustomComponentChange,
            },
        });
    }

    render() {
        if (hasCustomComponent(this.props.schema)) {
            return this.renderCustomComponent(this.props);
        }

        const fieldProps = {
            ...this.props,
            onChange: this.handleChange,
        };

        return React.createElement(JSONSchemaField, fieldProps);
    }
}
